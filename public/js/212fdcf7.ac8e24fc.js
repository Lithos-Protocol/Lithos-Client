"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[9642],{8700:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"tutorial-basics/lfsm-core","title":"LFSM Core","description":"The core LFSM contracts concern the maintenance of LFSM rollups. Rollups are generated every time a miner on Lithos finds a new block.","source":"@site/docs/tutorial-basics/lfsm-core.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/lfsm-core","permalink":"/assets/docs/tutorial-basics/lfsm-core","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"lfsm","permalink":"/assets/docs/tags/lfsm"}],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"tags":["lfsm"]},"sidebar":"tutorialSidebar","previous":{"title":"LFSM","permalink":"/assets/docs/tutorial-basics/lfsm"},"next":{"title":"Mining on Lithos","permalink":"/assets/docs/tutorial-basics/mining-on-lithos"}}');var o=t(74848),i=t(28453);const s={sidebar_position:4,tags:["lfsm"]},a="LFSM Core",l={},c=[{value:"Holding Phase",id:"holding-phase",level:2},{value:"NISP Submissions",id:"nisp-submissions",level:3},{value:"Holding Transformation",id:"holding-transformation",level:3},{value:"Evaluation Phase",id:"evaluation-phase",level:2},{value:"Fraud Proof Application",id:"fraud-proof-application",level:3},{value:"Evaluation Transformation",id:"evaluation-transformation",level:3},{value:"Payout Phase",id:"payout-phase",level:2},{value:"Payout Application",id:"payout-application",level:3}];function h(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"lfsm-core",children:"LFSM Core"})}),"\n",(0,o.jsxs)(n.p,{children:["The core LFSM contracts concern the maintenance of LFSM rollups. Rollups are generated ",(0,o.jsx)(n.strong,{children:"every time a miner on Lithos finds a new block."}),"\r\nEach LFSM Rollup is considered an ",(0,o.jsx)(n.em,{children:"optimistic rollup"}),", which has three phases and five transformations. Each rollup state is represented by the AVL Tree in ",(0,o.jsx)(n.em,{children:"R4"})," of the LFSM contract. This AVL Tree, called the ",(0,o.jsx)(n.em,{children:"NISP Tree"}),", holds all NISPs submitted by miners to prove that they performed work."]}),"\n",(0,o.jsx)(n.h2,{id:"holding-phase",children:"Holding Phase"}),"\n",(0,o.jsxs)(n.p,{children:["The Holding phase is the initial state of an LFSM rollup. When a collateral UTXO is included in a mined block, it is spent to create a new UTXO under the ",(0,o.jsx)(n.em,{children:"holding contract"}),". This UTXO has an empty AVL Tree in ",(0,o.jsx)(n.em,{children:"R4"}),", along with zeroed values for the number of miners (",(0,o.jsx)(n.em,{children:"R5"}),"),\r\nand total score (",(0,o.jsx)(n.em,{children:"R6"}),"). ",(0,o.jsx)(n.em,{children:"R7"})," of the ",(0,o.jsx)(n.em,{children:"holding contract"})," defines the start of the current phase, which is the blockheight of the mined block."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="holding.ergo"',children:"  // REGISTERS\r\n  // R4: NISP Tree, initially, an empty AVL Tree. AVL Tree of ( hashedPropBytes -> NISP )\r\n  // R5: Total Miners (incremented every NISP posted) for this period\r\n  // R6: Total Share Score (added to for every NISP posted, using given ShareScore from first 8 bytes of NISP)\r\n  // NOTE: R6 is of type BigInt, but share scores are of type Long. This is NOT a tau representation of score!!!\r\n  // It is simply the sum of all (Long) share scores stored in a BigInt value, so as to save blockchain space.\r\n  // R7: Period Start (time or height of block mining in which this box was created, ex. during block mining and collateral exchange)\r\n  \r\n  val nispTree:      AvlTree = SELF.R4[AvlTree].get\r\n  val currentMiners: Int     = SELF.R5[Int].get\r\n  val totalScore:    Long    = SELF.R6[BigInt].get\r\n  val currentPeriod: Long    = SELF.R7[Long].get\n"})}),"\n",(0,o.jsx)(n.h3,{id:"nisp-submissions",children:"NISP Submissions"}),"\n",(0,o.jsxs)(n.p,{children:["While ",(0,o.jsx)(n.code,{children:"HEIGHT < currentPeriod + HOLDING_PERIOD"}),", miners may submit NISPs to the holding contract. As the LFSM uses optimistic rollups,\r\nminimal evaluation of NISPs occurs when submitted. ",(0,o.jsx)(n.strong,{children:"Only the first 8 bytes of the NISP are checked"}),", these bytes contain the score which is then added to the ",(0,o.jsx)(n.code,{children:"totalScore"})," register on the holding contract output. Additionally, the digest of the NISP Tree and the value of ",(0,o.jsx)(n.code,{children:"currentMiners"})," is updated."]}),"\n",(0,o.jsx)(n.h3,{id:"holding-transformation",children:"Holding Transformation"}),"\n",(0,o.jsxs)(n.p,{children:["Once ",(0,o.jsx)(n.code,{children:"HEIGHT >= currentPeriod + HOLDING_PERIOD"}),", NISP submissions to the contract are no longer accepted. At this point, any miner may perform the ",(0,o.jsx)(n.em,{children:"holding transformation"}),", to transition the phase of this UTXO from ",(0,o.jsx)(n.code,{children:"HOLDING"})," to ",(0,o.jsx)(n.code,{children:"EVAL"}),". The transformation takes the holding contract and outputs a new ",(0,o.jsx)(n.em,{children:"evaluation contract"}),". ",(0,o.jsx)(n.strong,{children:"All but two registers stay the same during this transformation."})," ",(0,o.jsx)(n.em,{children:"R7"})," is updated to the height of the blockchain at the time of the transformation. Additionally, the value of ",(0,o.jsx)(n.code,{children:"currentPeriod"})," from the holding contract is copied into ",(0,o.jsx)(n.em,{children:"R8"})," of the evaluation contract, as this is used in certain fraud proofs."]}),"\n",(0,o.jsx)(n.h2,{id:"evaluation-phase",children:"Evaluation Phase"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"EVAL"})," state of an LFSM Rollup deals with the evaluation of all submitted NISPs. After the end of the ",(0,o.jsx)(n.code,{children:"HOLDING"})," phase, all NISP submissions are closed down. At this point, miners running ",(0,o.jsx)(n.strong,{children:"Lithos clients will attempt to prove fraudulence for every single miner found in the NISP Tree."})," To do this, miners must use one of the authenticated fraud proof contracts found in ",(0,o.jsx)(n.em,{children:"R4"})," of the ",(0,o.jsx)(n.code,{children:"FP_CONTROL"})," UTXO."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="evaluation.ergo"',children:"  // REGISTERS\r\n  // R4: NISP Tree, filled with submissions ( hashedPropBytes -> NISP )\r\n  // R5: Total Miners (decremented after FP posted) for this period\r\n  // R6: Total Share Score (subtracted from after valid FP is posted)\r\n  // R7: Period Start (time or height of block mining in which this box was created, in this case after holding period.)\r\n  // R8: Current Block (Period Start from holding contract)\r\n\r\n  val nispTree:      AvlTree = SELF.R4[AvlTree].get\r\n  val currentMiners: Int     = SELF.R5[Int].get\r\n  val totalScore:    Long    = SELF.R6[BigInt].get\r\n  val currentPeriod: Long    = SELF.R7[Long].get\r\n  val currentBlock:  Long    = SELF.R8[Long].get\r\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"fraud-proof-application",children:"Fraud Proof Application"}),"\n",(0,o.jsxs)(n.p,{children:["Application of a fraud proof to an evaluation contract implies the existence of fraud for a certain miner. There are a number of\r\ndifferent fraud proofs which exist on the ",(0,o.jsx)(n.code,{children:"FP_CONTROL"})," UTXO, each one checks certain aspects of a NISP to verify that a fraudulence occurred. Despite the differences between each fraud proof, all fraud proofs verify the following actions are performed after fraud is proven for a miner:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The miner is removed from the NISP Tree"}),"\n",(0,o.jsxs)(n.li,{children:["The miner's score is subtracted from ",(0,o.jsx)(n.code,{children:"totalScore"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"currentMiners"})," is decremented by one"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These actions ensure that a fraudulent miner's rewards are slashed, and that payout calculations remain correct in the next phase."}),"\n",(0,o.jsx)(n.h3,{id:"evaluation-transformation",children:"Evaluation Transformation"}),"\n",(0,o.jsxs)(n.p,{children:["Similar to the holding contract, fraud proof evaluation only occurs while ",(0,o.jsx)(n.code,{children:"HEIGHT < currentPeriod + EVAL_PERIOD"}),". Once\r\n",(0,o.jsx)(n.code,{children:"HEIGHT >= currentPeriod + EVAL_PERIOD"}),", the evaluation contract is ready to be transitioned to the ",(0,o.jsx)(n.code,{children:"PAYOUT"})," state.\r\nThis transformation is quite simple, in that ",(0,o.jsx)(n.strong,{children:"almost all registers are conserved."})," The only difference is that ",(0,o.jsx)(n.em,{children:"R7"})," goes from\r\nbeing ",(0,o.jsx)(n.code,{children:"currentPeriod"})," to ",(0,o.jsx)(n.code,{children:"blockReward"})," on the ",(0,o.jsx)(n.em,{children:"payout contract"}),", with its value initialized to the total amount of ERG held in the evaluation contract. ",(0,o.jsx)(n.em,{children:"R8"})," is not checked in the payout contract."]}),"\n",(0,o.jsx)(n.h2,{id:"payout-phase",children:"Payout Phase"}),"\n",(0,o.jsxs)(n.p,{children:["Once evaluation has completed, it is assumed that all remaining miners on the NISP Tree are truthful miners. At this point, it is time for miners to receive ERG for mining on the Lithos pool. Miners receive ERG according to the amount of work they performed. Work is measured using the ",(0,o.jsx)(n.code,{children:"score"})," found in the first 8 bytes of miner's submitted NISP."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="payout.ergo"',children:"  // REGISTERS\r\n  // R4: NISP Tree, filled with miners which passed evaluation period ( hashedPropBytes -> NISP )\r\n  // R5: Total Miners, constant on spend\r\n  // R6: Total Share Score constant on spend\r\n  // R7: Total block reward, equal to initial block value when transforming from EvalContract\r\n  \r\n  val nispTree:      AvlTree = SELF.R4[AvlTree].get\r\n  val currentMiners: Int     = SELF.R5[Int].get\r\n  val totalScore:    BigInt  = SELF.R6[BigInt].get\r\n  val totalReward:   Long    = SELF.R7[Long].get\n"})}),"\n",(0,o.jsx)(n.h3,{id:"payout-application",children:"Payout Application"}),"\n",(0,o.jsx)(n.p,{children:"Any miner may apply a transaction which performs payouts for any number of miners remaining in the NISP Tree. Once a payout is performed, the miner is removed from the NISP Tree so that duplicate payments do not occur. Payment is calculated in the following manner:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:" ((totalReward.toBigInt * minerScore.toBigInt) / totalScore).toLong\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If less than ",(0,o.jsx)(n.code,{children:"0.001 ERG"})," remains in the payout contract, a miner may fully spend the payout utxo without creating a corresponding output for it."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(96540);const o={},i=r.createContext(o);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);