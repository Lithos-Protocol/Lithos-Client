{
  // FP_InvalidDiff
  // Value: unspecified (0.001 ERG)
  // Proves fraud by showing that miner submitted a share which does not reach the super share threshold

  // REGISTERS
  // None

  val evalBox:       Box     = INPUTS(0)
  val nispTree:      AvlTree = evalBox.R4[AvlTree].get
  val currentMiners: Int     = evalBox.R5[Int].get
  val totalScore:    BigInt  = evalBox.R6[BigInt].get
  val currentPeriod: Long    = evalBox.R7[Long].get
  val currentBlock:  Long    = evalBox.R8[Long].get

  // NEXT VALUES
  val nextUTXO   = OUTPUTS(0)
  val nextTree   = nextUTXO.R4[AvlTree].get
  val nextMiners = nextUTXO.R5[Int].get
  val nextScore  = nextUTXO.R6[BigInt].get
  val nextPeriod = nextUTXO.R7[Long].get
  val nextBlock  = nextUTXO.R8[Long].get

  // CONTEXT VARS
  // CTX_MINER_BYTES(0) - Hashed PropBytes of miner who committed fraud
  // CTX_LOOKUP_PROOF(1) - Lookup proof for miner
  // CTX_REMOVE_PROOF(2) - Removal proof for miner
  val CTX_MINER_BYTES      = getVar[Coll[Byte]](0).getOrElse(Coll(0.toByte))
  val CTX_LOOKUP_PROOF     = getVar[Coll[Byte]](1).getOrElse(Coll(0.toByte))
  val CTX_REMOVE_PROOF     = getVar[Coll[Byte]](2).getOrElse(Coll(0.toByte))
  // CONSTANTS
  // Constant sizes for various parts of NISPs, along with LFSM constants like TARGET_MAX and NISP_COEFFICIENT
  val CONST_HEADER_SIZE       = 220
  val CONST_PREHEADER_SIZE    = 179
  val CONST_SCORE_SIZE        = 8
  val CONST_LEAF_SIZE         = 32
  val CONST_LEVEL_SIZE        = 33
  val CONST_TARGET_MAX_LITHOS = bigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949")
  val CONST_NISP_COEFFICIENT  = 10000
  val CONST_N_SIZE            = 4

  // Helper Methods

  def convertTauOrScore(dividend: UnsignedBigInt): UnsignedBigInt = {
    CONST_TARGET_MAX_LITHOS.toUnsigned / dividend
  }

  def getScore(nispBytes: Coll[Byte]): Long = {
    byteArrayToLong(nispBytes.slice(0,CONST_SCORE_SIZE))
  }

  def getTau(nispBytes: Coll[Byte]): UnsignedBigInt = {
    convertTauOrScore(getScore(nispBytes).toBigInt.toUnsigned)
  }
  // NISPs are serialized as the following
  // [score: 8bytes][10 SuperShares]
  // Where SuperShares are serialized as the following
  // [N: 4bytes][header: 220bytes][numLevels: 1Byte][leaf: 33bytes][levels: numLevels * 33bytes]
  def getSuperShares(nispBytes: Coll[Byte]): Coll[Coll[Byte]] = {
    val shareBytes = nispBytes.slice(CONST_SCORE_SIZE, nispBytes.size)
    // Iterate 10 times for 10 shares. We can assume this is true as it is checked in other FP contracts
    val iters = Coll(0,1,2,3,4,5,6,7,8,9)
    val shares = iters.fold((Coll[Coll[Byte]](), 0), {
      (a: (Coll[Coll[Byte]], Int), b: Int) =>
        val numLevels: Byte = shareBytes(a._2 + CONST_N_SIZE + CONST_HEADER_SIZE)
        val totalLevels = numLevels.toInt * CONST_LEVEL_SIZE
        val end = a._2 + CONST_N_SIZE + CONST_HEADER_SIZE + 1 + CONST_LEAF_SIZE + totalLevels
        (a._1.append(Coll(shareBytes.slice(a._2, end))), end)
    })
    shares._1
  }

  def getHeader(shareBytes: Coll[Byte]): Header = {
    deserializeTo[Header](shareBytes.slice(CONST_N_SIZE, CONST_N_SIZE + CONST_HEADER_SIZE))
  }
  // Get bytes of pre-header, then hash it to create msg used in PoW
  def getMsg(shareBytes: Coll[Byte]): Coll[Byte] = {
    blake2b256(shareBytes.slice(CONST_N_SIZE, CONST_N_SIZE + CONST_PREHEADER_SIZE))
  }

  def getN(shareBytes: Coll[Byte]): Int = {
    fromBigEndianBytes[Int](shareBytes.slice(0, CONST_N_SIZE))
  }

  def getHeightAndNonce(shareBytes: Coll[Byte]): (Coll[Byte], Coll[Byte]) = {
    val header: Header = getHeader(shareBytes)
    (header.powNonce, longToByteArray(getHeader(shareBytes).height.toLong).slice(0, 4))
  }
  // Evaluation
  val minerNISP = nispTree.get(CTX_MINER_BYTES, CTX_LOOKUP_PROOF).get
  val minerTau = getTau(minerNISP)
  val minerShares = getSuperShares(minerNISP)
  val shareInfo: (Int, (Coll[Byte], (Coll[Byte], Coll[Byte]))) = minerShares.map{
    (x: Coll[Byte]) =>
      (getN(x), (getMsg(x), getHeightAndNonce(x)))
  }
  val superShareThreshold = minerTau / CONST_NISP_COEFFICIENT
  val shareTaus: Coll[BigInt] = shareInfo.map{
    // N: Int, msg: Coll[Byte], nonce: Coll[Byte], height: Coll[Byte]
    (x: (Int, (Coll[Byte], (Coll[Byte], Coll[Byte]))) ) =>
      powHit(32, x._2._1, x._2._2._1, x._2._2._2, x._1)
  }
  // There exists some share for which the miner did not reach the super share threshold
  val fraudExists = shareTaus.exists{
    (x: UnsignedBigInt) =>
      x > superShareThreshold
  }
  val score: Long = getScore(minerNISP)
  val minerRemoved = {
    val removeTree = nispTree.remove(Coll(CTX_MINER_BYTES), CTX_REMOVE_PROOF).get
    removeTree.digest == nextTree.digest
  }

  val changedRegisters = allOf(
    Coll(
      nextUTXO.value  == evalBox.value,
      minerRemoved,
      nextMiners      == currentMiners - 1,
      nextScore       == totalScore - score,
      nextPeriod      == currentPeriod,
      nextBlock       == currentBlock
    )
  )

  sigmaProp(fraudExists && changedRegisters)

}